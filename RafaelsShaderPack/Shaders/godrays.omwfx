uniform_bool bluenoise {
    header = "General";
	default = true;
    display_name = "Blue Noise";
	description = "Blue noise dithering";
}

uniform_bool horizonclipping {
    default = true;
    display_name = "Horizon Clipping";
    description = "Prevents the sun disc from being drawn below the horizon. Might cause an FPS hit.";
}

uniform_int cloudocclusiontype {
	default = 1;
	display_name = "Cloud Occlusion Type";
	description = "Prevents the sun disc and sun shafts from being drawn when occluded by clouds or the moons (0 = disabled, 1 = static, 2 = dynamic and requires at least clouds rendering enabled in VAIO)";
    min = 0;
    max = 2;
}

uniform_int Iterations
{
    default = 16;
    min = 1;
    max = 50;
    step = 1;
    display_name = "Iterations";
    description = "Number of iterations";
}

uniform_float raysunradius {
    default = 0.25;
    min = 0.1;
    max = 10.0;
    step = 0.1;
    display_name = "Ray Radius";
    description = "Radius around sun center that emits rays";
}

uniform_float raystrength {
    header = "Sun Rays";
    default = 1.85;
    min = 0.1;
    max = 10.0;
    step = 0.05;
    display_name = "Ray Strength";
    description = "Brightness of sun rays";
}

uniform_float rayColorR
{
    default = 1.0;
    min = 0.0;
    max = 1.0;
    step = 0.004;
    display_name = "Ray Color Red";
}

uniform_float rayColorG
{
    default = 0.85;
    min = 0.0;
    max = 1.0;
    step = 0.004;
    display_name = "Ray Color Green";
}

uniform_float rayColorB
{
    default = 0.66;
    min = 0.0;
    max = 1.0;
    step = 0.004;
    display_name = "Ray Color Blue";
}

uniform_float rayfalloff {
    default = 1.10;
    min = 0.1;
    max = 10.0;
    step = 0.1;
    display_name = "Ray Falloff";
    description = "Falloff of sun rays";
}

uniform_float rayfalloffconst {
    default = 0.125;
    min = 0.1;
    max = 10.0;
    step = 0.1;
    display_name = "Minimum Ray Length";
    description = "Increase to increase minimum 'length' of sun rays";
}

uniform_float raysunfalloff {
    default = 1.5;
    min = 0.1;
    max = 10.0;
    step = 0.1;
    display_name = "Ray Falloff Exponent";
    description = "Ray strength falloff exponent";
}

uniform_float centervis {
    default = 0.35;
    min = 0.1;
    max = 10.0;
    step = 0.01;
    display_name = "Sun Center Ray Opacity";
    description = "Ray opacity at center of sun";
}

uniform_float sunrayocclude {
    default = 0.75;
    min = 0.1;
    max = 10.0;
    step = 0.025;
    display_name = "Sun Occlude";
    description = "How much sun rays will 'overwrite' original image";
}

uniform_float raybrightness {
    default = 1.00;
    min = 0.1;
    max = 10.0;
    step = 0.05;
    display_name = "Ray Brightness";
    description = "Additional sun ray color brightness for very bright rays";
}

uniform_float offscreenrange {
    default = 0.5;
    min = 0.1;
    max = 10.0;
    step = 0.1;
    display_name = "Offscreen Ray Distance";
    description = "Maximum offscreen position of sun before rays vanish";
}

uniform_float sundiscradius {
    header = "Sun Disc";
    default = 0.025;
    min = 0.01;
    max = 10.0;
    step = 0.025;
    display_name = "Sun Radius";
    description = "Radius of sun disc";
}

uniform_float sundiscbrightness {
    default = 1.2;
    min = 0.1;
    max = 10.0;
    step = 0.1;
    display_name = "Sun Brightness";
    description = "Brightness of sun disc";
}

uniform_float sundiscdesaturate {
    default = 0.4;
    min = -10.0;
    max = 10.0;
    step = 0.1;
    display_name = "Sun Desaturation";
    description = "Desaturation of sun disc color, negative values for more saturation";
}

uniform_float sundiscocclude {
    default = 0.1;
    min = 0.1;
    max = 10.0;
    step = 0.1;
    display_name = "Sun Occlude";
    description = "How much the sun disc will 'overwrite' original image";
}

uniform_float sundischorizonmultiplier {
    default = 2.0;
    min = 0.0;
    max = 10.0;
    step = 0.1;
    display_name = "Sun Horizon Multiplier";
    description = "How much the sun disc will be brighter at the horizon, making the sunrises and sunsets more colorful";
}

sampler_2d Snoise {
    source = "textures/bluenoise.png";
    mag_filter = nearest;
    min_filter = nearest;
    wrap_s = repeat;
    wrap_t = repeat;
}

shared {
    const float scale = 2.0;
    const float rscale = 0.5;
    const float threshold = 1.0;

    vec2 getSunView()
    {
        vec4 pos = (omw.projectionMatrix * omw.viewMatrix) * omw.sunPos;
        pos.xy /= pos.w;
        pos.xy = pos.xy * 0.5 + 0.5;
        pos.y = 1.0 - pos.y;
        return vec2(pos.xy);
    }

    vec3 toWorld(vec2 tex)
    {
        vec3 v = vec3(omw.viewMatrix[0][2], omw.viewMatrix[1][2], omw.viewMatrix[2][2]);
        v += vec3(1.0/omw.projectionMatrix[0][0] * (2.0*(1.0 - tex.x)-1.0)) * vec3(omw.viewMatrix[0][0], omw.viewMatrix[1][0], omw.viewMatrix[2][0]);
        v += vec3(-1.0/omw.projectionMatrix[1][1] * (2.0*tex.y-1.0)) * vec3(omw.viewMatrix[0][1], omw.viewMatrix[1][1], omw.viewMatrix[2][1]);
        v.z *= -1.0;
        return v;
    }

    vec2 scale_uv(vec2 uv, vec2 scale, vec2 center) {
		return (uv - center) * scale + center;
	}
    
    //Array of sun occlusion per weather ID
	float sun_occlusion[10]=float[](
		float(0.00),  //Clear
		float(0.25),  //Cloudy
		float(1.00),  //Foggy
		float(0.75),  //Overcast
		float(1.00),  //Rain
		float(1.00),  //Thunder
		float(0.80),  //Ash
		float(0.80),  //Blight
		float(0.25),  //Snow
		float(0.85)   //Blizzard
	);
    
    float GetInvSunVis()
    {
        float f = sun_occlusion[omw.weatherID];
        if (omw.nextWeatherID >= 0)
            f = mix(f, sun_occlusion[omw.nextWeatherID], omw.weatherTransition);
        return clamp(f, 0.0f, 1.0f);
    }
}


render_target RT_Stretch
{
    width_ratio  = 1.0;
    height_ratio = 1.0;
    internal_format = red;
    source_format = red;
}

fragment stretch(target=RT_Stretch)
{
    omw_In vec2 omw_TexCoord;

    void main()
    {
        vec2 Tex = omw_TexCoord;
        Tex.y = 1.0 - Tex.y;
        vec2 cutoff = 1.1 * rscale - Tex;
        if(cutoff.y < 0.0 || cutoff.x < 0.0)
            discard;

        float depth = 0.0;

        vec3 sundir = -normalize(omw.sunPos.xyz);
        float forward = dot(sundir, omw.eyeVec.xyz);

        if(forward < 0.0)
        {
            vec2 srcTex = scale * Tex;
            srcTex.y = 1.0 - srcTex.y;
            depth = step(threshold, omw_GetDepth(srcTex));
            depth += step(threshold, omw_GetDepth(srcTex + vec2(omw.rcpResolution.x, 0.0)));
            depth += step(threshold, omw_GetDepth(srcTex + vec2(0.0, omw.rcpResolution.y)));
            depth += step(threshold, omw_GetDepth(srcTex + vec2(omw.rcpResolution.x, omw.rcpResolution.y)));
            depth *= 0.25f;
            
            if (cloudocclusiontype == 2)
            {
                const float cloudThreshold = 0.75f;
                float d2;
                d2 =  step(cloudThreshold, omw_GetLastShader(srcTex).a);
                d2 += step(cloudThreshold, omw_GetLastShader(srcTex + vec2(omw.rcpResolution.x, 0.0)).a);
                d2 += step(cloudThreshold, omw_GetLastShader(srcTex + vec2(0.0, omw.rcpResolution.y)).a);
                d2 += step(cloudThreshold, omw_GetLastShader(srcTex + vec2(omw.rcpResolution.x, omw.rcpResolution.y)).a);
                d2 *= 0.25f;
                d2 += smoothstep(0.1f, 0.0f, -sundir.z);
                depth = min(depth, d2);
            }
        }

        omw_FragColor.r = depth;
    }
}

render_target RT_Blur
{
    width_ratio  = 1.0;
    height_ratio = 1.0;
    internal_format = red;
    source_format = red;
}

fragment blurRHalf(target=RT_Blur, rt1=RT_Stretch)
{
    omw_In vec2 omw_TexCoord;

    void main()
    {
        vec2 Tex = omw_TexCoord;
        Tex.y = 1.0 - Tex.y;
        vec2 cutoff = 1.1 * rscale - Tex;
        if(cutoff.y < 0.0 || cutoff.x < 0.0)
            discard;

        vec2 sunviewhalf = 0.5 * getSunView();

        Tex.y = 1.0 - Tex.y;
        vec2 radial = normalize(Tex - sunviewhalf).xy * omw.rcpResolution.yx;

        float alpha;
        alpha  = 0.3333 * omw_Texture2D(RT_Stretch, Tex).r;
        alpha += 0.2222 * omw_Texture2D(RT_Stretch, Tex + radial).r;
        alpha += 0.2222 * omw_Texture2D(RT_Stretch, Tex - radial).r;
        alpha += 0.1111 * omw_Texture2D(RT_Stretch, Tex + 2.0*radial).r;
        alpha += 0.1111 * omw_Texture2D(RT_Stretch, Tex - 2.0*radial).r;

        omw_FragColor.r = alpha;
    }
}

render_target RT_Rays
{
    width_ratio  = 0.5;
    height_ratio = 0.5;
    internal_format = red;
    source_format = red;
}

fragment rays(target=RT_Rays, rt1=RT_Blur)
{
    omw_In vec2 omw_TexCoord;

    void main()
    {
        vec3 sundir = -normalize(omw.sunPos.xyz);
        float forward = dot(sundir, omw.eyeVec.xyz);
        if(forward >= 0.0)
        {
            omw_FragColor = vec4(0.0);
            return;
        }

        vec2 Tex = omw_TexCoord;
        Tex.y = 1.0 - Tex.y;

		float timer = omw.simulationTime * 0.5;
		float offset = 0.0;

        float raspect = omw.rcpResolution.x / omw.rcpResolution.y;

		if(bluenoise) {
            offset = texture2D(Snoise, 3.2 * Tex * vec2(1.0, raspect)).r;
			offset = fract(offset + timer * 0.61803398875);
		}

        vec2 sunview = getSunView();
        float strength = raystrength * 1.0 * smoothstep(-offscreenrange, 0.0, 0.5-abs(sunview.x-0.5)) * smoothstep(-offscreenrange, 0.0, 0.5-abs(sunview.y-0.5));

        vec2 screendir = (Tex - sunview);

        float screendist = length(screendir * vec2(1.0, raspect));
        screendir /= screendist;

        float sunr = min(raysunradius, screendist);
        float l = 0.0;
        
        float rayfalloffdyn = rayfalloff;
        
        for(int i = 1; i <= Iterations; i++)
        {
            float sundist = (float(i) + offset) / float(Iterations) * sunr;
            sundist *= clamp(offset * 0.05f, 0.0f, 0.05f) + 0.975f;

            vec2 coords = clamp(sunview + sundist * screendir, vec2(0.0), vec2(1.0)) * rscale;
            coords.y = 1.0 - coords.y;

            l += omw_Texture2D(RT_Blur, coords).r * exp(-((screendist-sundist)/(rayfalloffconst+sundist)) * rayfalloffdyn) * pow(1.0 - clamp(sundist/raysunradius, 0.0, 1.0), raysunfalloff);
        }

        float oneminuscentervis = 1.0 - centervis;

        l *= strength / float(Iterations)* (screendist/raysunradius * oneminuscentervis + centervis);

        // vec4 col = vec4(rayColorR * omw.sunColor.r, rayColorG * omw.sunColor.g, rayColorB * omw.sunColor.b, l);
        // col.rgb *= 1.0 + raybrightness * pow(col.a, 3.0);

        omw_FragColor = vec4(l);
    }
}

vertex combine
{
    #if OMW_USE_BINDINGS
        omw_In vec2 omw_Vertex;
    #endif

    omw_Out vec2 omw_TexCoord;
    omw_Out float light;

    void main()
    {
        omw_Position = vec4(omw_Vertex.xy, 0.0, 1.0);
        omw_TexCoord = omw_Position.xy * 0.5 + 0.5;

        float niceweather = 1.0;
        if (omw.weatherTransition != 0.0 && omw.nextWeatherID >= 0 && omw.nextWeatherID <= 9)
        {
            niceweather = mix((omw.weatherID <= 1) ? 1.0 : 0.0, (omw.nextWeatherID <= 1) ? 1.0 : 0.0, omw.weatherTransition);
            niceweather *= niceweather;
        }
        else
            niceweather = (omw.weatherID <= 1) ? 1.0 : 0.0;

        float sunvis = mix(omw.sunVis, 1.0, 0.333 * niceweather);
        light = 1.0 - pow(1.0 - sunvis, 2.0);
    }
}

fragment combine(rt1=RT_Rays)
{
    omw_In vec2 omw_TexCoord;
    omw_In float light;

    float InterleavedGradientNoise(vec2 uv)
    {
        float noise = fract(52.9829189f * fract(0.06711056f * uv.x + 0.00583715f * uv.y));
        // triangulate!
        noise = noise * 2.0f - 1.0f;
        return noise;
    }

    void main()
    {
        vec4 col = vec4(0);
    
        vec3 sundir = -normalize(omw.sunPos.xyz);
        float forward = dot(sundir, omw.eyeVec.xyz);
        if(forward < 0.0)
        {
            vec2 Tex = omw_TexCoord;
            vec2 tanTex = vec2(-1 * Tex.x, 1-Tex.y);
    
            vec2 sunview = getSunView();
    
            vec2 tangent = 1.0 * normalize(tanTex - sunview).yx * vec2(omw.rcpResolution.y, -omw.rcpResolution.x);
    
            col.a  = 0.3333 * omw_Texture2D(RT_Rays, Tex).r;
            col.a += 0.2222 * omw_Texture2D(RT_Rays, Tex + tangent).r;
            col.a += 0.2222 * omw_Texture2D(RT_Rays, Tex - tangent).r;
            col.a += 0.1111 * omw_Texture2D(RT_Rays, Tex + 2.0*tangent).r;
            col.a += 0.1111 * omw_Texture2D(RT_Rays, Tex - 2.0*tangent).r;
            
            // col.a -= InterleavedGradientNoise(omw_TexCoord * omw.resolution) / 64.0f;
            
            col.rgb = omw.sunColor.rgb;
            // col.rgb = mix(col.rgb, vec3(dot(col.rgb, vec3(0.2126f, 0.7152f, 0.0722f))), 0.2f);
            if (col.r < col.b)
                col.rb = col.br;
            
            col.rgb = vec3(rayColorR * col.r, rayColorG * col.g, rayColorB * col.b);
            col.rgb *= 1.0 + raybrightness * col.a * col.a * col.a;
            
            // omw_FragColor = vec4(col.a); return;
            // omw_FragColor.rgb = col.rgb * col.a; return;
        }
        vec4 ray = col;

        col = omw_GetLastShader(omw_TexCoord);

		float sunDirVis = (omw.sunPos.z) * 20.0f; // 20 because we want to make 5% into 100%
		sunDirVis = clamp(sunDirVis, 0.0f, 1.0f);
		ray.a *= sunDirVis;

		if (cloudocclusiontype > 0)
        {
            float sunVis = 1.0f - GetInvSunVis();
            
            if (cloudocclusiontype == 1)
                ray.a *= sunVis;
            else
            {
                sunVis = mix(sunVis, 1.0f, smoothstep(0.10f, 0.15f, omw.sunPos.z));
                ray.a *= sunVis;
            }
        }

        col *= clamp(1.0 - sunrayocclude * ray.a, 0.0, 1.0);
        col.rgb = clamp(col.rgb + ray.rgb * ray.a, 0.0, 1.0);

        float raspect = omw.rcpResolution.x / omw.rcpResolution.y;

        if (forward < 0.0)
        {
            vec2 Tex = omw_TexCoord;
            Tex.y = 1.0 - Tex.y;

            vec2 screendir = Tex - getSunView();
            screendir.y *= raspect;

            float sharpness = mix(60.0, 660.0 + 360.0 * sundir.z, clamp(omw.fogNear / 480.0, 0.0, 1.0));

            float occl = light * step(threshold, omw_GetDepth(omw_TexCoord));
            occl *= clamp(exp2(sharpness * (sundiscradius - length(screendir))), 0.0, 1.0);

            if(occl > 0.004)
            {
                vec3 suncoldisc = vec3(1, 0.76+0.24*omw.sunPos.z, 0.54+0.46*omw.sunPos.z)
                                        * clamp(omw.sunColor.rgb/max(omw.sunColor.r,max(omw.sunColor.g, omw.sunColor.b))
                                         * (1.0 - sundiscdesaturate) + vec3(sundiscdesaturate), 0.0, 1.0);
                float horizonBoost = (1.0f + sundischorizonmultiplier * min(
                    smoothstep(-0.1f, 0.05f, omw.sunPos.z),
                    smoothstep(0.20f, 0.05f, omw.sunPos.z)
                    ));
                vec3 scol = suncoldisc * sundiscbrightness * horizonBoost;
                if (horizonclipping)
                {
                    float aziHorizon = normalize(vec2(4.0f * omw.fogFar, -omw.eyePos.z)).y;
                    float azi = normalize(toWorld(omw_TexCoord)).z;
                    occl *= smoothstep(-0.005, 0.010, azi - aziHorizon);
                    scol.gb *= smoothstep(-0.04, 0.09, azi - aziHorizon);
                }
                
                if (cloudocclusiontype == 2)
                {
                    float cloudOcclusion = col.a * col.a;
                    cloudOcclusion = clamp((cloudOcclusion - 0.4f) * 2.5f, 0.0f, 1.0f);
                    occl *= cloudOcclusion;
                }
                
                col.rgb = mix(col.rgb, scol, sundiscocclude * occl * horizonBoost);
            }
        }
        
        // #define DEBUG_SUNVIS
        #ifdef DEBUG_SUNVIS
        if(omw_TexCoord.x < (sunDirVis + 0.001f) && omw_TexCoord.y > 0.95) col.rgb = mix(col.rgb, vec3(0.9), vec3(0.4));
        #endif

        omw_FragColor = vec4(col.rgb, 1.0f);
    }
}

technique {
    passes = stretch, blurRHalf, rays, combine;
    description = "Screen Space God rays";
    author = "Phal, Hrnchamd, Dexter, Wazabear, Rafael";
    version = "1.8";
    flags = Disable_Interiors, Disable_SunGlare, Disable_Underwater;
}
