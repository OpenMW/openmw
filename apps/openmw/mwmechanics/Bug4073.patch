diff --git a/apps/openmw/mwmechanics/autocalcspell.cpp b/apps/openmw/mwmechanics/autocalcspell.cpp
index f655a68b48..a4045aa2e4 100644
--- a/apps/openmw/mwmechanics/autocalcspell.cpp
+++ b/apps/openmw/mwmechanics/autocalcspell.cpp
@@ -65,13 +65,22 @@ namespace MWMechanics
         for (MWWorld::Store<ESM::Spell>::iterator iter = spells.begin(); iter != spells.end(); ++iter)
         {
             const ESM::Spell* spell = &*iter;
+            
+            /// Get the min cost of the spell.
+            const ESM::EffectList& effects = spell->mEffects;
+            float minCost = 0;
+            for (std::vector<ESM::ENAMstruct>::const_iterator it = effects.mList.begin(); it != effects.mList.end(); ++it)
+            {
+                const ESM::ENAMstruct& effect = *it;
+                minCost += calcEffectCost(effect);
+            }
 
             if (spell->mData.mType != ESM::Spell::ST_Spell)
                 continue;
             if (!(spell->mData.mFlags & ESM::Spell::F_Autocalc))
                 continue;
             static const int iAutoSpellTimesCanCast = gmst.find("iAutoSpellTimesCanCast")->getInt();
-            if (baseMagicka < iAutoSpellTimesCanCast * spell->mData.mCost)
+            if (baseMagicka < iAutoSpellTimesCanCast * minCost)
                 continue;
 
             if (race && race->mPowers.exists(spell->mId))
@@ -86,7 +95,7 @@ namespace MWMechanics
             assert(school >= 0 && school < 6);
             SchoolCaps& cap = schoolCaps[school];
 
-            if (cap.mReachedLimit && spell->mData.mCost <= cap.mMinCost)
+            if (cap.mReachedLimit && minCost <= cap.mMinCost)
                 continue;
 
             static const float fAutoSpellChance = gmst.find("fAutoSpellChance")->getFloat();
@@ -131,10 +140,10 @@ namespace MWMechanics
                 if (cap.mCount == cap.mLimit)
                     cap.mReachedLimit = true;
 
-                if (spell->mData.mCost < cap.mMinCost)
+                if (minCost < cap.mMinCost)
                 {
                     cap.mWeakestSpell = spell->mId;
-                    cap.mMinCost = spell->mData.mCost;
+                    cap.mMinCost = minCost;
                 }
             }
         }
