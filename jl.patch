diff --git apps/openmw/mwbase/mechanicsmanager.hpp apps/openmw/mwbase/mechanicsmanager.hpp
index d9068b285b..1e55b3c59a 100644
--- apps/openmw/mwbase/mechanicsmanager.hpp
+++ apps/openmw/mwbase/mechanicsmanager.hpp
@@ -8,6 +8,7 @@
 #include <stdint.h>
 
 #include "../mwworld/ptr.hpp"
+#include "../../../components/esm/regencreatures.hpp"
 
 namespace osg
 {
@@ -75,6 +76,12 @@ namespace MWBase
 
             virtual void advanceTime (float duration) = 0;
 
+            virtual void addRegenCreature(ESM::RegenCreature rCreature) = 0;
+
+            virtual bool isRegenCreatureInStack(ESM::RegenCreature rCreature) = 0;
+
+            virtual void regenCreatures() = 0;
+
             virtual void setPlayerName (const std::string& name) = 0;
             ///< Set player name.
 
diff --git apps/openmw/mwbase/world.hpp apps/openmw/mwbase/world.hpp
index 5e76d82eba..1a86f91256 100644
--- apps/openmw/mwbase/world.hpp
+++ apps/openmw/mwbase/world.hpp
@@ -429,6 +429,8 @@ namespace MWBase
             virtual void getItemsOwnedBy (const MWWorld::ConstPtr& npc, std::vector<MWWorld::Ptr>& out) = 0;
             ///< get all items in active cells owned by this Npc
 
+            virtual void getCreatureById(unsigned int id, MWWorld::Ptr& out) = 0;
+
             virtual bool getLOS(const MWWorld::ConstPtr& actor,const MWWorld::ConstPtr& targetActor) = 0;
             ///< get Line of Sight (morrowind stupid implementation)
 
diff --git apps/openmw/mwmechanics/actors.cpp apps/openmw/mwmechanics/actors.cpp
index cef4295047..b06d6dbdc3 100644
--- apps/openmw/mwmechanics/actors.cpp
+++ apps/openmw/mwmechanics/actors.cpp
@@ -481,12 +481,12 @@ namespace MWMechanics
         creatureStats.setMagicka(magicka);
     }
 
-    void Actors::restoreDynamicStats (const MWWorld::Ptr& ptr, bool sleep)
+    template <typename T>
+    void Actors::restoreDynamicStatsVar(const MWWorld::Ptr& ptr, bool sleep, T &stats)
     {
-        if (ptr.getClass().getCreatureStats(ptr).isDead())
+        if (stats.isDead())
             return;
 
-        MWMechanics::CreatureStats& stats = ptr.getClass().getCreatureStats (ptr);
         const MWWorld::Store<ESM::GameSetting>& settings = MWBase::Environment::get().getWorld()->getStore().get<ESM::GameSetting>();
 
         if (sleep)
@@ -503,23 +503,36 @@ namespace MWMechanics
             stats.setMagicka(stat);
         }
 
-        int endurance = stats.getAttribute (ESM::Attribute::Endurance).getModified ();
+        int endurance = stats.getAttribute(ESM::Attribute::Endurance).getModified();
 
         float normalizedEncumbrance = ptr.getClass().getNormalizedEncumbrance(ptr);
         if (normalizedEncumbrance > 1)
             normalizedEncumbrance = 1;
 
         // restore fatigue
-        float fFatigueReturnBase = settings.find("fFatigueReturnBase")->getFloat ();
-        float fFatigueReturnMult = settings.find("fFatigueReturnMult")->getFloat ();
-        float fEndFatigueMult = settings.find("fEndFatigueMult")->getFloat ();
+        float fFatigueReturnBase = settings.find("fFatigueReturnBase")->getFloat();
+        float fFatigueReturnMult = settings.find("fFatigueReturnMult")->getFloat();
+        float fEndFatigueMult = settings.find("fEndFatigueMult")->getFloat();
 
         float x = fFatigueReturnBase + fFatigueReturnMult * (1 - normalizedEncumbrance);
         x *= fEndFatigueMult * endurance;
 
         DynamicStat<float> fatigue = stats.getFatigue();
-        fatigue.setCurrent (fatigue.getCurrent() + 3600 * x);
-        stats.setFatigue (fatigue);
+        fatigue.setCurrent(fatigue.getCurrent() + 3600 * x);
+        stats.setFatigue(fatigue);
+    }
+
+    void Actors::restoreDynamicStatsNPC(const MWWorld::Ptr& ptr, bool sleep)
+    {
+
+        MWMechanics::CreatureStats& stats = ptr.getClass().getNpcStats(ptr);
+        restoreDynamicStatsVar(ptr, sleep, stats);
+    }
+
+    void Actors::restoreDynamicStats (const MWWorld::Ptr& ptr, bool sleep)
+    {
+        MWMechanics::CreatureStats& stats = ptr.getClass().getCreatureStats (ptr);
+        restoreDynamicStatsVar(ptr, sleep, stats);
     }
 
     void Actors::calculateRestoration (const MWWorld::Ptr& ptr, float duration)
diff --git apps/openmw/mwmechanics/actors.hpp apps/openmw/mwmechanics/actors.hpp
index e433434a54..855d6e15f2 100644
--- apps/openmw/mwmechanics/actors.hpp
+++ apps/openmw/mwmechanics/actors.hpp
@@ -100,8 +100,13 @@ namespace MWMechanics
             void rest(bool sleep);
             ///< Update actors while the player is waiting or sleeping. This should be called every hour.
 
+            template <typename T>
+            void restoreDynamicStatsVar(const MWWorld::Ptr& ptr, bool sleep, T &stats);
+
             void restoreDynamicStats(const MWWorld::Ptr& actor, bool sleep);
 
+            void restoreDynamicStatsNPC(const MWWorld::Ptr & ptr, bool sleep);
+
             int getHoursToRest(const MWWorld::Ptr& ptr) const;
             ///< Calculate how many hours the given actor needs to rest in order to be fully healed
 
diff --git apps/openmw/mwmechanics/mechanicsmanagerimp.cpp apps/openmw/mwmechanics/mechanicsmanagerimp.cpp
index 5d9ef726a3..1169bfef18 100644
--- apps/openmw/mwmechanics/mechanicsmanagerimp.cpp
+++ apps/openmw/mwmechanics/mechanicsmanagerimp.cpp
@@ -1,5 +1,6 @@
 #include "mechanicsmanagerimp.hpp"
 
+
 #include <limits.h>
 
 #include <components/misc/rng.hpp>
@@ -27,6 +28,7 @@
 #include "npcstats.hpp"
 #include "actorutil.hpp"
 #include "combat.hpp"
+#include "actor.hpp"
 
 namespace
 {
@@ -269,6 +271,7 @@ namespace MWMechanics
             mActors.updateActor(old, ptr);
         else
             mObjects.updateObject(old, ptr);
+
     }
 
 
@@ -292,6 +295,78 @@ namespace MWMechanics
         player.getClass().getInventoryStore(player).rechargeItems(duration);
     }
 
+    void MechanicsManager::regenCreatures()
+    {
+        ESM::TimeStamp curTime = MWBase::Environment::get().getWorld()->getTimeStamp().toEsm();
+        for (std::vector<ESM::RegenCreature>::iterator it = mRegenCreatures.begin(); it != mRegenCreatures.end();)
+        {
+            ESM::RegenCreature &rCreature = *it;
+            MWWorld::Ptr ptr;
+            MWBase::Environment::get().getWorld()->getCreatureById(rCreature.mId, ptr);
+            if (ptr.isEmpty()) {
+                it++;
+                continue;
+            }
+
+            bool isNPC = ptr.getTypeName() == typeid (ESM::NPC).name();
+            bool isCreature = ptr.getTypeName() == typeid (ESM::Creature).name();
+            if (isNPC)
+            {
+                MWMechanics::NpcStats& stats = ptr.getClass().getNpcStats(ptr);
+                if (stats.isDead())
+                {
+                    it = mRegenCreatures.erase(it);
+                    continue;
+                }
+                stats.setKnockedDown(false);
+
+                if (stats.getHealth().getCurrent() == stats.getHealth().getModified() && stats.getMagicka().getCurrent() == stats.getMagicka().getModified() &&
+                    stats.getFatigue().getCurrent() == stats.getFatigue().getModified())
+                {
+                    it = mRegenCreatures.erase(it);
+                    continue;
+                }
+            }
+            else if (isCreature)
+            {
+                MWMechanics::CreatureStats& stats = ptr.getClass().getCreatureStats(ptr);
+                if (stats.isDead())
+                {
+                    it = mRegenCreatures.erase(it);
+                    continue;
+                }
+
+                stats.setKnockedDown(false);
+
+                if (stats.getHealth().getCurrent() == stats.getHealth().getModified() && stats.getMagicka().getCurrent() == stats.getMagicka().getModified() &&
+                    stats.getFatigue().getCurrent() == stats.getFatigue().getModified())
+                {
+                    it = mRegenCreatures.erase(it);
+                     continue;
+                }
+            }
+       
+            int durationElapsedHours = std::floor((curTime.mDay*24 + curTime.mHour) - (rCreature.mTimeStamp.mDay*24 + rCreature.mTimeStamp.mHour));
+            rCreature.mTimeStamp = curTime;
+            for (int i = 0; i < durationElapsedHours; ++i)
+            {
+                if (isNPC)
+                    mActors.restoreDynamicStatsNPC(ptr, true);
+                else if (isCreature)
+                    mActors.restoreDynamicStats(ptr, true);
+            }
+            ++it;
+        }
+    }
+
+
+    bool MechanicsManager::isRegenCreatureInStack(ESM::RegenCreature rCreature)
+    {
+        std::vector<ESM::RegenCreature>::iterator it;
+        it = std::find_if(mRegenCreatures.begin(), mRegenCreatures.end(), [rCreature](ESM::RegenCreature o) { return o.mId == rCreature.mId; });
+        return (it != mRegenCreatures.end());
+    }
+
     void MechanicsManager::update(float duration, bool paused)
     {
         if(!mWatched.isEmpty())
@@ -1531,7 +1606,8 @@ namespace MWMechanics
     int MechanicsManager::countSavedGameRecords() const
     {
         return 1 // Death counter
-                +1; // Stolen items
+            + 1 // Stolen items
+            + 1; // Regen Creatures.
     }
 
     void MechanicsManager::write(ESM::ESMWriter &writer, Loading::Listener &listener) const
@@ -1543,6 +1619,13 @@ namespace MWMechanics
         writer.startRecord(ESM::REC_STLN);
         items.write(writer);
         writer.endRecord(ESM::REC_STLN);
+
+        
+        ESM::RegenCreatures rCreatures;
+        rCreatures.mRegenCreatures = mRegenCreatures;
+        writer.startRecord(ESM::REC_RGNT);
+        rCreatures.write(writer);
+        writer.endRecord(ESM::REC_RGNT);
     }
 
     void MechanicsManager::readRecord(ESM::ESMReader &reader, uint32_t type)
@@ -1553,6 +1636,12 @@ namespace MWMechanics
             items.load(reader);
             mStolenItems = items.mStolenItems;
         }
+        else if (type == ESM::REC_RGNT)
+        {
+            ESM::RegenCreatures rCreatures;
+            rCreatures.load(reader);
+            mRegenCreatures = rCreatures.mRegenCreatures;
+        }
         else
             mActors.readRecord(reader, type);
     }
@@ -1561,6 +1650,7 @@ namespace MWMechanics
     {
         mActors.clear();
         mStolenItems.clear();
+        mRegenCreatures.clear();
         mClassSelected = false;
         mRaceSelected = false;
     }
diff --git apps/openmw/mwmechanics/mechanicsmanagerimp.hpp apps/openmw/mwmechanics/mechanicsmanagerimp.hpp
index 1bf3a8d227..b827818f57 100644
--- apps/openmw/mwmechanics/mechanicsmanagerimp.hpp
+++ apps/openmw/mwmechanics/mechanicsmanagerimp.hpp
@@ -44,6 +44,8 @@ namespace MWMechanics
             typedef std::map<std::string, OwnerMap> StolenItemsMap;
             StolenItemsMap mStolenItems;
 
+            std::vector<ESM::RegenCreature> mRegenCreatures;
+
         public:
 
             void buildPlayer();
@@ -76,6 +78,14 @@ namespace MWMechanics
 
             virtual void advanceTime (float duration);
 
+            virtual void addRegenCreature(ESM::RegenCreature rCreature) {
+                mRegenCreatures.push_back(rCreature);
+            }
+
+            virtual void regenCreatures();
+
+            virtual bool isRegenCreatureInStack(ESM::RegenCreature rCreature);
+
             virtual void setPlayerName (const std::string& name);
             ///< Set player name.
 
diff --git apps/openmw/mwstate/statemanagerimp.cpp apps/openmw/mwstate/statemanagerimp.cpp
index 14ee5adee1..2366f5107b 100644
--- apps/openmw/mwstate/statemanagerimp.cpp
+++ apps/openmw/mwstate/statemanagerimp.cpp
@@ -464,6 +464,10 @@ void MWState::StateManager::loadGame (const Character *character, const std::str
                     MWBase::Environment::get().getMechanicsManager()->readRecord(reader, n.intval);
                     break;
 
+                case ESM::REC_RGNT:
+                    MWBase::Environment::get().getMechanicsManager()->readRecord(reader, n.intval);
+                    break;
+
                 case ESM::REC_INPU:
                     MWBase::Environment::get().getInputManager()->readRecord(reader, n.intval);
                     break;
diff --git apps/openmw/mwworld/cellref.cpp apps/openmw/mwworld/cellref.cpp
index 72ee56e6a1..872733203c 100644
--- apps/openmw/mwworld/cellref.cpp
+++ apps/openmw/mwworld/cellref.cpp
@@ -5,7 +5,7 @@
 namespace MWWorld
 {
 
-    const ESM::RefNum& CellRef::getRefNum() const
+    ESM::RefNum CellRef::getRefNum() const
     {
         return mCellRef.mRefNum;
     }
diff --git apps/openmw/mwworld/cellref.hpp apps/openmw/mwworld/cellref.hpp
index 7e27e6ef33..f4e5ef7796 100644
--- apps/openmw/mwworld/cellref.hpp
+++ apps/openmw/mwworld/cellref.hpp
@@ -23,8 +23,8 @@ namespace MWWorld
         }
 
         // Note: Currently unused for items in containers
-        const ESM::RefNum& getRefNum() const;
-
+        ESM::RefNum getRefNum() const;
+        
         // Set RefNum to its default state.
         void unsetRefNum();
 
diff --git apps/openmw/mwworld/cellstore.cpp apps/openmw/mwworld/cellstore.cpp
index b4f260a25d..42f00a6029 100644
--- apps/openmw/mwworld/cellstore.cpp
+++ apps/openmw/mwworld/cellstore.cpp
@@ -397,6 +397,24 @@ namespace MWWorld
         return searchVisitor.mFound;
     }
 
+    Ptr CellStore::searchViaCreatureId(int id)
+    {
+        if (Ptr ptr = ::searchViaActorId(mNpcs, id, this, mMovedToAnotherCell))
+            return ptr;
+
+        if (Ptr ptr = ::searchViaActorId(mCreatures, id, this, mMovedToAnotherCell))
+            return ptr;
+
+        for (MovedRefTracker::const_iterator it = mMovedHere.begin(); it != mMovedHere.end(); ++it)
+        {
+            MWWorld::Ptr actor(it->first, this);
+            if (actor.getClass().getCreatureStats(actor).matchesActorId(id) && actor.getRefData().getCount() > 0)
+                return actor;
+        }
+
+        return Ptr();
+    }
+
     Ptr CellStore::searchViaActorId (int id)
     {
         if (Ptr ptr = ::searchViaActorId (mNpcs, id, this, mMovedToAnotherCell))
diff --git apps/openmw/mwworld/cellstore.hpp apps/openmw/mwworld/cellstore.hpp
index 4452ad8892..5ae9f7867d 100644
--- apps/openmw/mwworld/cellstore.hpp
+++ apps/openmw/mwworld/cellstore.hpp
@@ -230,6 +230,8 @@ namespace MWWorld
             Ptr searchViaActorId (int id);
             ///< Will return an empty Ptr if cell is not loaded.
 
+            Ptr searchViaCreatureId(int id);
+
             float getWaterLevel() const;
 
             void setWaterLevel (float level);
diff --git apps/openmw/mwworld/cellvisitors.hpp apps/openmw/mwworld/cellvisitors.hpp
index cfb07f7492..cc23c23d11 100644
--- apps/openmw/mwworld/cellvisitors.hpp
+++ apps/openmw/mwworld/cellvisitors.hpp
@@ -24,6 +24,36 @@ namespace MWWorld
             return true;
         }
     };
+
+    struct CreatureObjectsVisitor
+    {
+        std::vector<MWWorld::Ptr> mObjects;
+
+        bool operator() (MWWorld::Ptr ptr)
+        {
+            if (ptr.getTypeName() == typeid (ESM::Creature).name())
+            {
+                mObjects.push_back(ptr);
+            }
+
+            return true;
+        }
+    };
+
+    struct NpcObjectsVisitor
+    {
+        std::vector<MWWorld::Ptr> mObjects;
+
+        bool operator() (MWWorld::Ptr ptr)
+        {
+            if (ptr.getTypeName() == typeid (ESM::NPC).name())
+            {
+                mObjects.push_back(ptr);
+            }
+
+            return true;
+        }
+    };
 }
 
 #endif
diff --git apps/openmw/mwworld/scene.cpp apps/openmw/mwworld/scene.cpp
index c831652395..a38a11c701 100644
--- apps/openmw/mwworld/scene.cpp
+++ apps/openmw/mwworld/scene.cpp
@@ -3,6 +3,7 @@
 #include <limits>
 #include <iostream>
 
+#include <components/esm/regencreatures.hpp>
 #include <components/loadinglistener/loadinglistener.hpp>
 #include <components/misc/resourcehelpers.hpp>
 #include <components/settings/settings.hpp>
@@ -20,6 +21,8 @@
 
 #include "../mwphysics/physicssystem.hpp"
 
+#include "../mwmechanics/npcstats.hpp"
+
 #include "player.hpp"
 #include "localscripts.hpp"
 #include "esmstore.hpp"
@@ -28,6 +31,8 @@
 #include "cellstore.hpp"
 #include "cellpreloader.hpp"
 
+
+
 namespace
 {
 
@@ -226,10 +231,32 @@ namespace MWWorld
 
         mPreloader->updateCache(mRendering.getReferenceTime());
     }
-
+    
     void Scene::unloadCell (CellStoreCollection::iterator iter)
     {
         std::cout << "Unloading cell\n";
+        for (CellStoreCollection::iterator iter = mActiveCells.begin(); iter != mActiveCells.end(); ++iter)
+        {
+            CreatureObjectsVisitor visitor;
+            (*iter)->forEach<CreatureObjectsVisitor>(visitor);
+            for (std::vector<MWWorld::Ptr>::iterator iter2 = visitor.mObjects.begin();
+                iter2 != visitor.mObjects.end(); ++iter2)
+            {
+                MWWorld::Ptr &ptr = (*iter2);
+                MWMechanics::CreatureStats& stats = ptr.getClass().getCreatureStats(ptr);
+                checkRegen(ptr, stats);
+            }
+            NpcObjectsVisitor visitor2;
+            (*iter)->forEach<NpcObjectsVisitor>(visitor2);
+            for (std::vector<MWWorld::Ptr>::iterator iter2 = visitor2.mObjects.begin();
+                iter2 != visitor2.mObjects.end(); ++iter2)
+            {
+                MWWorld::Ptr &ptr = (*iter2);
+                MWMechanics::NpcStats &stats = ptr.getClass().getNpcStats(ptr);
+                checkRegen(ptr, stats);
+            }
+        }
+
         ListAndResetObjectsVisitor visitor;
 
         (*iter)->forEach<ListAndResetObjectsVisitor>(visitor);
@@ -317,8 +344,31 @@ namespace MWWorld
             if (!cell->isExterior() && !(cell->getCell()->mData.mFlags & ESM::Cell::QuasiEx))
                 mRendering.configureAmbient(cell->getCell());
         }
-
         mPreloader->notifyLoaded(cell);
+
+        MWBase::Environment::get().getMechanicsManager()->regenCreatures();
+    }
+
+    template <typename T>
+    void Scene::checkRegen(MWWorld::Ptr &ptr, T &stats)
+    {
+        if (stats.isDead())
+            return;
+
+        if (stats.getHealth().getCurrent() != stats.getHealth().getModified() ||
+            stats.getMagicka().getCurrent() != stats.getMagicka().getModified() ||
+            stats.getFatigue().getCurrent() != stats.getFatigue().getModified())
+        {
+            ESM::RegenCreature rechargeCreature;
+            MWWorld::CellRef &cRef = ptr.getCellRef();
+            cRef.getRefNum().setIndex(stats.getActorId());
+            rechargeCreature.mId = stats.getActorId();
+
+            rechargeCreature.mTimeStamp = MWBase::Environment::get().getWorld()->getTimeStamp().toEsm();
+            
+            if (!MWBase::Environment::get().getMechanicsManager()->isRegenCreatureInStack(rechargeCreature))
+                MWBase::Environment::get().getMechanicsManager()->addRegenCreature(rechargeCreature);
+        }
     }
 
     void Scene::clear()
diff --git apps/openmw/mwworld/scene.hpp apps/openmw/mwworld/scene.hpp
index e2fac64383..a59e925967 100644
--- apps/openmw/mwworld/scene.hpp
+++ apps/openmw/mwworld/scene.hpp
@@ -96,6 +96,9 @@ namespace MWWorld
 
             void loadCell (CellStore *cell, Loading::Listener* loadingListener, bool respawn);
 
+            template <typename T>
+            void checkRegen(MWWorld::Ptr &ptr, T &stats);
+
             void playerMoved (const osg::Vec3f& pos);
 
             void changePlayerCell (CellStore* newCell, const ESM::Position& position, bool adjustPlayerPos);
diff --git apps/openmw/mwworld/worldimp.cpp apps/openmw/mwworld/worldimp.cpp
index a9506385d4..3396bf2a10 100644
--- apps/openmw/mwworld/worldimp.cpp
+++ apps/openmw/mwworld/worldimp.cpp
@@ -1159,6 +1159,7 @@ namespace MWWorld
 
         if (currCell != newCell)
         {
+            
             removeContainerScripts(ptr);
 
             if (isPlayer)
@@ -2484,6 +2485,16 @@ namespace MWWorld
         }
     }
 
+    void World::getCreatureById(const unsigned int id, MWWorld::Ptr& out)
+    {
+        const Scene::CellStoreCollection& collection = mWorldScene->getActiveCells();
+        for (Scene::CellStoreCollection::const_iterator cellIt = collection.begin(); cellIt != collection.end(); ++cellIt)
+        {
+            MWWorld::CellStore* cellStore = (*cellIt);
+            out = cellStore->searchViaCreatureId(id);
+        }
+    }
+
     bool World::getLOS(const MWWorld::ConstPtr& actor, const MWWorld::ConstPtr& targetActor)
     {
         if (!targetActor.getRefData().isEnabled() || !actor.getRefData().isEnabled())
diff --git apps/openmw/mwworld/worldimp.hpp apps/openmw/mwworld/worldimp.hpp
index a15dcaf3dd..f46de31df2 100644
--- apps/openmw/mwworld/worldimp.hpp
+++ apps/openmw/mwworld/worldimp.hpp
@@ -539,6 +539,8 @@ namespace MWWorld
             virtual void getItemsOwnedBy (const MWWorld::ConstPtr& npc, std::vector<MWWorld::Ptr>& out);
             ///< get all items in active cells owned by this Npc
 
+            virtual void getCreatureById(const unsigned int id, MWWorld::Ptr& out);
+
             virtual bool getLOS(const MWWorld::ConstPtr& actor,const MWWorld::ConstPtr& targetActor);
             ///< get Line of Sight (morrowind stupid implementation)
 
diff --git components/CMakeLists.txt components/CMakeLists.txt
index 88de179039..debdb72b86 100644
--- components/CMakeLists.txt
+++ components/CMakeLists.txt
@@ -77,7 +77,7 @@ add_component_dir (esm
     loadweap records aipackage effectlist spelllist variant variantimp loadtes3 cellref filter
     savedgame journalentry queststate locals globalscript player objectstate cellid cellstate globalmap inventorystate containerstate npcstate creaturestate dialoguestate statstate
     npcstats creaturestats weatherstate quickkeys fogstate spellstate activespells creaturelevliststate doorstate projectilestate debugprofile
-    aisequence magiceffects util custommarkerstate stolenitems transport animationstate controlsstate
+    aisequence magiceffects util custommarkerstate stolenitems regencreatures transport animationstate controlsstate
     )
 
 add_component_dir (esmterrain
diff --git components/esm/cellref.cpp components/esm/cellref.cpp
index e41201d6e6..3be1b3db2f 100644
--- components/esm/cellref.cpp
+++ components/esm/cellref.cpp
@@ -10,7 +10,8 @@ void ESM::RefNum::load (ESMReader& esm, bool wide, const std::string& tag)
     if (wide)
         esm.getHNT (*this, tag.c_str(), 8);
     else
-        esm.getHNT (mIndex, tag.c_str());
+        esm.getHNT(mIndex, tag.c_str());
+
 }
 
 void ESM::RefNum::save (ESMWriter &esm, bool wide, const std::string& tag) const
diff --git components/esm/cellref.hpp components/esm/cellref.hpp
index f146175316..62495c5003 100644
--- components/esm/cellref.hpp
+++ components/esm/cellref.hpp
@@ -23,6 +23,8 @@ namespace ESM
         enum { RefNum_NoContentFile = -1 };
         inline bool hasContentFile() const { return mContentFile != RefNum_NoContentFile; }
         inline void unset() { mIndex = 0; mContentFile = RefNum_NoContentFile; }
+
+        inline void setIndex(unsigned int index) { mIndex = index; }
     };
 
     /* Cell reference. This represents ONE object (of many) inside the
diff --git components/esm/creaturestats.cpp components/esm/creaturestats.cpp
index beb2c4c64c..0b16b8aeb9 100644
--- components/esm/creaturestats.cpp
+++ components/esm/creaturestats.cpp
@@ -2,6 +2,8 @@
 #include "esmreader.hpp"
 #include "esmwriter.hpp"
 
+unsigned int ESM::CreatureStats::nextActorId = INT_MAX;
+
 void ESM::CreatureStats::load (ESMReader &esm)
 {
     for (int i=0; i<8; ++i)
@@ -90,6 +92,9 @@ void ESM::CreatureStats::load (ESMReader &esm)
     mActorId = -1;
     esm.getHNOT (mActorId, "ACID");
 
+    if (mActorId == 0)
+        mActorId = generateActorId();
+
     //mHitAttemptActorId = -1;
     //esm.getHNOT(mHitAttemptActorId, "HAID");
 
@@ -203,8 +208,7 @@ void ESM::CreatureStats::save (ESMWriter &esm) const
     if (mLevel != 1)
         esm.writeHNT ("LEVL", mLevel);
 
-    if (mActorId != -1)
-        esm.writeHNT ("ACID", mActorId);
+    esm.writeHNT ("ACID", mActorId);
 
     //if (mHitAttemptActorId != -1)
     //    esm.writeHNT("HAID", mHitAttemptActorId);
diff --git components/esm/creaturestats.hpp components/esm/creaturestats.hpp
index 7e7e5dac37..c148708958 100644
--- components/esm/creaturestats.hpp
+++ components/esm/creaturestats.hpp
@@ -66,11 +66,23 @@ namespace ESM
         SpellState mSpells;
         ActiveSpells mActiveSpells;
 
+        static unsigned int nextActorId;
+
         /// Initialize to default state
         void blank();
 
         void load (ESMReader &esm);
         void save (ESMWriter &esm) const;
+
+        static int generateActorId()
+        {
+            return nextActorId++;
+        }
+
+        unsigned int getActorId()
+        {
+            return mActorId;
+        }
     };
 }
 
diff --git components/esm/defs.hpp components/esm/defs.hpp
index 0f0478faab..ffa52a17b1 100644
--- components/esm/defs.hpp
+++ components/esm/defs.hpp
@@ -128,6 +128,7 @@ enum RecNameInts
     REC_CAM_ = FourCC<'C','A','M','_'>::value,
     REC_STLN = FourCC<'S','T','L','N'>::value,
     REC_INPU = FourCC<'I','N','P','U'>::value,
+    REC_RGNT = FourCC<'R','G','N','T'>::value,
 
     // format 1
     REC_FILT = FourCC<'F','I','L','T'>::value,
